/**
类型

*/
use num::complex::Complex;

/**
 -------------------------- 整型 ------------------------
默认：i32
 */
/**
【整型溢出】
①“补码循环溢出（two’s complement wrapping）”规则：
  大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1
②要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：
  使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
  如果使用 checked_* 方法时发生溢出，则返回 None 值
  使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
  使用 saturating_* 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值
 */
fn wrapping() {
    let a : u8 = 255; // u8范围：0~255
    let b = a.wrapping_add(20);
    println!("{}", b);  // 19
}

/**
---------------------------- 浮点型 --------------------------
f32类型是单精度，f64双精度
默认：f64

判断一个数值是否是 NaN：使用 is_nan() 等方法

避免在浮点数上测试相等性
当结果在数学上可能存在未定义时，需要格外的小心
 */


/**
---------------------------- 有理数和复数 --------------------------
 */
fn complex() {
    let a = Complex { re: 2.1, im: -1.2 };
    let b = Complex::new(11.1, 22.2);
    let result = a + b;

    println!("{} + {}i", result.re, result.im)
}

/**
---------------------------- 单元类型() -------------------------------
可以用来表达一个函数没有返回值：
函数没有返回值，那么返回一个 ()
*/
use std::fmt::Debug;
// 隐式返回()
fn report<T: Debug>(item: T) {
    println!("{:?}", item);
}
// 显式返回()
fn clear(text: &mut String) -> () {
    *text = String::from("");
}

/**
--------------------------- 字符串类型 -------------------------------
例①：【字符串字面值】
let s ="hello"，
s 是被硬编码进程序里的字符串值（类型为 &str ）。

字符串字面值是很方便的，但是它并不适用于所有场景。原因有二：
（1）字符串字面值是不可变的，因为被硬编码到程序代码中
（2）并非所有字符串的值都能在编写代码时得知（如需要通过用户动态输入然后存储在内存中）

例②：【动态字符串类型】: String
该类型被分配到堆上，因此可以动态伸缩，也就能存储在编译时大小未知的文本。
注意：String不是基本类型，是复杂类型。由①存储在栈中的堆指针、字符串②长度、字符串③容量共同组成
*/
fn string_example() {
    let mut s = String::from("hello"); // ::是一种调用操作符，这里表示调用String模块中的from方法

    s.push_str(", world!"); // push_str() 在字符串后追加字面值

    println!("{}", s); // `hello, world!`
}
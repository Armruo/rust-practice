/**
类型

*/
use num::complex::Complex;

/**
 -------------------------- 整型 ------------------------
默认：i32
 */
/**
【整型溢出】
①“补码循环溢出（two’s complement wrapping）”规则：
  大于该类型最大值的数值会被补码转换成该类型能够支持的对应数字的最小值。比如在 u8 的情况下，256 变成 0，257 变成 1
②要显式处理可能的溢出，可以使用标准库针对原始数字类型提供的这些方法：
  使用 wrapping_* 方法在所有模式下都按照补码循环溢出规则处理，例如 wrapping_add
  如果使用 checked_* 方法时发生溢出，则返回 None 值
  使用 overflowing_* 方法返回该值和一个指示是否存在溢出的布尔值
  使用 saturating_* 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值
 */
fn wrapping() {
    let a : u8 = 255; // u8范围：0~255
    let b = a.wrapping_add(20);
    println!("{}", b);  // 19
}

/**
---------------------------- 浮点型 --------------------------
f32类型是单精度，f64双精度
默认：f64

判断一个数值是否是 NaN：使用 is_nan() 等方法

避免在浮点数上测试相等性
当结果在数学上可能存在未定义时，需要格外的小心
 */


/**
---------------------------- 有理数和复数 --------------------------
 */
fn complex() {
    let a = Complex { re: 2.1, im: -1.2 };
    let b = Complex::new(11.1, 22.2);
    let result = a + b;

    println!("{} + {}i", result.re, result.im)
}
